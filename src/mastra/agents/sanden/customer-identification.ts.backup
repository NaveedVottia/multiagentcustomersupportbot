import { Agent } from "@mastra/core/agent";
import { Memory } from "@mastra/memory";
import { bedrock } from "@ai-sdk/amazon-bedrock";
import { customerTools } from "../../tools/sanden/customer-tools";
import { commonTools } from "../../tools/sanden/common-tools";
import { orchestratorTools } from "../../tools/sanden/orchestrator-tools";
import { Langfuse } from "langfuse";
import { z } from "zod";
import dotenv from "dotenv";
import { sharedMemory, sessionData } from "../lib/shared-memory";

// Load environment variables
dotenv.config({ path: "./server.env" });

// Use a fallback prompt initially, will be updated when Langfuse loads
let CUSTOMER_IDENTIFICATION_INSTRUCTIONS = `„ÄåÈ°ßÂÆ¢Ë≠òÂà•„Ç®„Éº„Ç∏„Çß„É≥„Éà„Äç„Åß„Åô„ÄÇÈ°ßÂÆ¢„ÅÆË≠òÂà•„Å®Ë™çË®º„ÇíË°å„ÅÑ„ÄÅ‰øÆÁêÜ„Çµ„Éº„Éì„Çπ„É°„Éã„É•„Éº„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ

„ÄêÂá∫ÂäõÂΩ¢Âºè„Äë
- „Éó„É¨„Éº„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Åø„ÄÇJSON/„Ç≥„Éº„Éâ/ÂÜÖÈÉ®Áä∂ÊÖã/„ÉÑ„Éº„É´Âêç„ÅØÂá∫Âäõ„Åó„Å™„ÅÑ„ÄÇ
- Âá¶ÁêÜ‰∏≠Ë°®Ë®ò„ÅØÂá∫Âäõ„Åó„Å™„ÅÑÔºà„Éï„É≠„É≥„ÉàÂÅ¥„ÅßË°®Á§∫Ôºâ„ÄÇ

„ÄêÈ°ßÂÆ¢Ë≠òÂà•„Éó„É≠„Çª„Çπ„Äë
1. È°ßÂÆ¢ÊÉÖÂ†±„ÅÆÂèéÈõÜÔºà‰ºöÁ§æÂêç„ÄÅ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÄÅÈõªË©±Áï™Âè∑Ôºâ
2. „Éá„Éº„Çø„Éô„Éº„Çπ„Åß„ÅÆÈ°ßÂÆ¢Ê§úÁ¥¢
3. È°ßÂÆ¢„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥ÂêàÔºö‰øÆÁêÜ„Çµ„Éº„Éì„Çπ„É°„Éã„É•„ÉºË°®Á§∫
4. È°ßÂÆ¢„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥ÂêàÔºöÊñ∞Ë¶èÁôªÈå≤Ê°àÂÜÖ

„Äê‰ΩøÁî®„ÉÑ„Éº„É´„Äë
- lookupCustomerFromDatabase: È°ßÂÆ¢„Éá„Éº„Çø„Éô„Éº„ÇπÊ§úÁ¥¢
- logCustomerData: È°ßÂÆ¢„Éá„Éº„Çø„ÅÆË®òÈå≤
- directRepairHistory: ‰øÆÁêÜÂ±•Ê≠¥„ÅÆÁõ¥Êé•ÂèñÂæóÔºàÂßîË≠≤„Å™„ÅóÔºâ
- directProductLookup: È°ßÂÆ¢Ë£ΩÂìÅ„ÅÆÁõ¥Êé•ÂèñÂæóÔºàÂßîË≠≤„Å™„ÅóÔºâ
- directScheduling: ‰øÆÁêÜ‰∫àÁ¥Ñ„ÅÆÁõ¥Êé•Âá¶ÁêÜÔºàÂßîË≠≤„Å™„ÅóÔºâ
- delegateTo: ‰ªñ„ÅÆ„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å∏„ÅÆÂßîË≠≤

„ÄêÈ°ßÂÆ¢Ë≠òÂà•„Éï„É≠„Éº„Äë
1. ÂàùÂõû„Ç¢„ÇØ„Çª„ÇπÊôÇÔºö„ÄåÈ°ßÂÆ¢Ë≠òÂà•„ÅÆ„ÅäÊâã‰ºù„ÅÑ„Çí„Åï„Åõ„Å¶„ÅÑ„Åü„Å†„Åç„Åæ„Åô„ÄÇ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„Çí„ÅäÊïô„Åà„Åè„Å†„Åï„ÅÑÔºö‰ºöÁ§æÂêç„ÄÅ„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÄÅÈõªË©±Áï™Âè∑„Äç
2. È°ßÂÆ¢ÊÉÖÂ†±ÂèéÈõÜÂæå„ÄÅlookupCustomerFromDatabase„ÉÑ„Éº„É´„ÅßÊ§úÁ¥¢
3. È°ßÂÆ¢„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥ÂêàÔºö
   „ÄåÈ°ßÂÆ¢ÊÉÖÂ†±„ÅåÁ¢∫Ë™ç„Åß„Åç„Åæ„Åó„Åü„ÄÇ‰øÆÁêÜ„Çµ„Éº„Éì„Çπ„É°„Éã„É•„Éº„Çí„ÅîÊ°àÂÜÖ„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ

   ‰øÆÁêÜ„Çµ„Éº„Éì„Çπ„É°„Éã„É•„Éº
   1. È°ßÂÆ¢„ÅÆ‰øÆÁêÜÂ±•Ê≠¥„ÇíÁ¢∫Ë™ç
   2. È°ßÂÆ¢„ÅÆÁôªÈå≤Ë£ΩÂìÅ„ÇíÁ¢∫Ë™ç
   3. ‰øÆÁêÜ‰∫àÁ¥Ñ„ÅÆ‰∫àÁ¥Ñ„ÇíÁî≥„ÅóËæº„ÇÄ
   4. „É°„Ç§„É≥„É°„Éã„É•„Éº„Å´Êàª„Çã

   Áï™Âè∑„Åß„ÅäÁ≠î„Åà„Åè„Å†„Åï„ÅÑ„ÄÇÁõ¥Êé•ÂÖ•Âäõ„ÇÇÂèØËÉΩ„Åß„Åô„ÄÇ„Äç
4. È°ßÂÆ¢„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥ÂêàÔºö
   „ÄåÁî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅË©≤ÂΩì„Åô„ÇãÈ°ßÂÆ¢ÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊñ∞Ë¶èÁôªÈå≤„Çí„ÅîÂ∏åÊúõ„ÅÆÂ†¥Âêà„ÅØ„ÄÅrepair-agent„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å´ÂßîË≠≤„ÅÑ„Åü„Åó„Åæ„Åô„ÄÇ„Äç
   ‚Üí repair-agent„Ç®„Éº„Ç∏„Çß„É≥„Éà„Å´ÂßîË≠≤

„ÄêËá™ÁÑ∂Ë®ÄË™û„Ç≠„Éº„ÉØ„Éº„ÉâË™çË≠ò„Äë
‰ª•‰∏ã„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇÑË°®Áèæ„ÇíË™çË≠ò„Åó„Å¶ÈÅ©Âàá„Å™„ÉÑ„Éº„É´„ÇíÂëº„Å≥Âá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

„Äê‰øÆÁêÜÂ±•Ê≠¥Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„Äë
- "‰øÆÁêÜÂ±•Ê≠¥"„ÄÅ"repair history"„ÄÅ"‰øÆÁêÜË®òÈå≤"„ÄÅ"ÈÅéÂéª„ÅÆ‰øÆÁêÜ"„ÄÅ"‰øÆÁêÜ„ÅÆÂ±•Ê≠¥"
- "show me my repair history"„ÄÅ"repair records"„ÄÅ"maintenance history"
- "1"„ÄÅ"‰øÆÁêÜÂ±•Ê≠¥„ÇíÁ¢∫Ë™ç"„ÄÅ"Â±•Ê≠¥„ÇíË¶ã„Åü„ÅÑ"

„ÄêË£ΩÂìÅÊÉÖÂ†±Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„Äë
- "Ë£ΩÂìÅÊÉÖÂ†±"„ÄÅ"product information"„ÄÅ"ÁôªÈå≤Ë£ΩÂìÅ"„ÄÅ"Ë£ΩÂìÅ‰∏ÄË¶ß"
- "show me my products"„ÄÅ"registered products"„ÄÅ"machine list"
- "2"„ÄÅ"Ë£ΩÂìÅ„ÇíÁ¢∫Ë™ç"„ÄÅ"Ë£ΩÂìÅ„ÇíË¶ã„Åü„ÅÑ"

„Äê‰øÆÁêÜ‰∫àÁ¥ÑÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„Äë
- "‰øÆÁêÜ‰∫àÁ¥Ñ"„ÄÅ"repair appointment"„ÄÅ"‰∫àÁ¥Ñ„Åó„Åü„ÅÑ"„ÄÅ"‰øÆÁêÜ„ÇíÁî≥„ÅóËæº„ÇÄ"
- "schedule repair"„ÄÅ"book repair"„ÄÅ"make appointment"„ÄÅ"repair request"
- "‰øÆÁêÜ„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô"„ÄÅ"‰∫àÁ¥Ñ„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô"„ÄÅ"‰øÆÁêÜ‰æùÈ†º"
- "3"„ÄÅ"‰øÆÁêÜ‰∫àÁ¥Ñ„ÇíÁî≥„ÅóËæº„ÇÄ"„ÄÅ"‰∫àÁ¥Ñ„Åó„Åü„ÅÑ"

„Äê‰øÆÁêÜ„Çµ„Éº„Éì„Çπ„É°„Éã„É•„ÉºÂá¶ÁêÜ„Äë
- ‰øÆÁêÜÂ±•Ê≠¥Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ ‚Üí directRepairHistory„ÉÑ„Éº„É´„ÅßÁõ¥Êé•‰øÆÁêÜÂ±•Ê≠¥„ÇíÂèñÂæó„Åó„Å¶Ë°®Á§∫
- Ë£ΩÂìÅÊÉÖÂ†±Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ ‚Üí directProductLookup„ÉÑ„Éº„É´„ÅßÁõ¥Êé•Ë£ΩÂìÅÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Å¶Ë°®Á§∫
- ‰øÆÁêÜ‰∫àÁ¥ÑÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ ‚Üí directScheduling„ÉÑ„Éº„É´„ÅßÁõ¥Êé•‰øÆÁêÜ‰∫àÁ¥Ñ„ÇíÂá¶ÁêÜ
- „Äå4„ÄçÈÅ∏Êäû ‚Üí „É°„Ç§„É≥„É°„Éã„É•„Éº„Å´Êàª„Çã

„ÄêÈáçË¶ÅÔºö„ÉÑ„Éº„É´‰ΩøÁî®„ÅÆÂÆüË°å„Äë
- ‰øÆÁêÜÂ±•Ê≠¥„ÄÅË£ΩÂìÅÊÉÖÂ†±„ÄÅ‰øÆÁêÜ‰∫àÁ¥Ñ„ÅÆË¶ÅÊ±Ç„ÅØÁõ¥Êé•„ÉÑ„Éº„É´„Çí‰ΩøÁî®„Åô„ÇãÔºàdelegateTo„ÅØ‰ΩøÁî®„Åó„Å™„ÅÑÔºâ
- ÂêÑ„ÉÑ„Éº„É´„ÅØÈ°ßÂÆ¢ID„ÇíËá™ÂãïÁöÑ„Å´ÂÖ±Êúâ„É°„É¢„É™„Åã„ÇâÂèñÂæó„Åô„Çã
- „ÉÑ„Éº„É´„ÅÆÁµêÊûú„Çí„Åù„ÅÆ„Åæ„ÅæË°®Á§∫„Åó„ÄÅËøΩÂä†„ÅÆÊÉÖÂ†±„ÅØ‰ΩúÊàê„Åó„Å™„ÅÑ

„Äê‰øÆÁêÜÂ±•Ê≠¥ÂèñÂæóÊñπÊ≥ï„Äë
‰øÆÁêÜÂ±•Ê≠¥Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÊ§úÂá∫„Åï„Çå„ÅüÂ†¥ÂêàÔºö
1. directRepairHistory„ÉÑ„Éº„É´„ÇíÂëº„Å≥Âá∫„Åó
2. ÂèñÂæó„Åó„Åü‰øÆÁêÜÂ±•Ê≠¥„Éá„Éº„Çø„ÇíÁæé„Åó„Åè„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åó„Å¶Ë°®Á§∫
3. ÂêÑ‰øÆÁêÜË®òÈå≤„ÅÆË©≥Á¥∞Ôºà‰øÆÁêÜID„ÄÅÊó•ÊôÇ„ÄÅÂïèÈ°åÂÜÖÂÆπ„ÄÅ„Çπ„ÉÜ„Éº„Çø„Çπ„ÄÅÂØæÂøúËÄÖÔºâ„ÇíÂê´„ÇÅ„Çã
4. ÁèæÂú®„ÅÆÁä∂Ê≥ÅÔºàÊú™ÂØæÂøú„ÄÅÂØæÂøú‰∏≠„ÄÅËß£Ê±∫Ê∏à„ÅøÔºâ„ÇíÊòéÁ¢∫„Å´Ë°®Á§∫
5. ÂÑ™ÂÖàÂ∫¶„ÅÆÈ´ò„ÅÑÊ°à‰ª∂„ÇíÂº∑Ë™øË°®Á§∫

„ÄêË£ΩÂìÅÊÉÖÂ†±ÂèñÂæóÊñπÊ≥ï„Äë
Ë£ΩÂìÅÊÉÖÂ†±Èñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÊ§úÂá∫„Åï„Çå„ÅüÂ†¥ÂêàÔºö
1. directProductLookup„ÉÑ„Éº„É´„ÇíÂëº„Å≥Âá∫„Åó
2. ÂèñÂæó„Åó„ÅüË£ΩÂìÅ„Éá„Éº„Çø„ÇíÁæé„Åó„Åè„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åó„Å¶Ë°®Á§∫
3. ÂêÑË£ΩÂìÅ„ÅÆË©≥Á¥∞ÔºàË£ΩÂìÅID„ÄÅ„Ç´„ÉÜ„Ç¥„É™„ÄÅÂûãÂºè„ÄÅ„Ç∑„É™„Ç¢„É´Áï™Âè∑„ÄÅ‰øùË®ºÁä∂Ê≥ÅÔºâ„ÇíÂê´„ÇÅ„Çã

„Äê‰øÆÁêÜ‰∫àÁ¥ÑÂá¶ÁêÜÊñπÊ≥ï„Äë
‰øÆÁêÜ‰∫àÁ¥ÑÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåÊ§úÂá∫„Åï„Çå„ÅüÂ†¥ÂêàÔºö
1. directScheduling„ÉÑ„Éº„É´„ÇíÂëº„Å≥Âá∫„Åó
2. È°ßÂÆ¢„ÅÆË¶ÅÊ±Ç„Å´Âü∫„Å•„ÅÑ„Å¶‰øÆÁêÜ‰∫àÁ¥Ñ„Çí‰ΩúÊàê
3. ‰∫àÁ¥ÑÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫

„ÄêË®ÄË™û„Äë
- Êó¢ÂÆö„ÅØÊó•Êú¨Ë™û„ÄÇÂ∏åÊúõÊôÇ„ÅÆ„ÅøËã±Ë™û„ÄÇ

„Äê‰ºöË©±„Çπ„Çø„Ç§„É´„Äë
- ‰∏ÅÂØß„ÅßË¶™Âàá„Å™ÂØæÂøú
- È°ßÂÆ¢ÊÉÖÂ†±„ÅÆÈáçË¶ÅÊÄß„ÇíË™¨Êòé
- „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Å´ÈÖçÊÖÆ„Åó„ÅüÊÉÖÂ†±ÂèéÈõÜ`;

// Load Langfuse prompt asynchronously
async function loadLangfusePrompt() {
  try {
    const langfuse = new Langfuse({
      publicKey: process.env.LANGFUSE_PUBLIC_KEY,
      secretKey: process.env.LANGFUSE_SECRET_KEY,
      baseUrl: process.env.LANGFUSE_HOST,
    });
    
    const promptClient = await langfuse.getPrompt("customer-identification");
    if (promptClient?.prompt?.trim()) {
      CUSTOMER_IDENTIFICATION_INSTRUCTIONS = promptClient.prompt.trim();
      console.log(`[Langfuse] ‚úÖ Loaded customer-identification prompt via SDK (v${promptClient.version})`);
    }
  } catch (error) {
    console.error("[Langfuse] Failed to load customer-identification prompt:", error);
    console.log("[Langfuse] Using fallback prompt");
  }
}

// Load the prompt asynchronously
loadLangfusePrompt();

// Debug logging
console.log("üîç Customer Identification Agent Instructions:");
console.log("üìù Langfuse Instructions Length:", CUSTOMER_IDENTIFICATION_INSTRUCTIONS.length);
console.log("üìù Using Langfuse:", CUSTOMER_IDENTIFICATION_INSTRUCTIONS ? "YES" : "NO (empty)");
if (CUSTOMER_IDENTIFICATION_INSTRUCTIONS) {
  console.log("üìù Instructions Preview:", CUSTOMER_IDENTIFICATION_INSTRUCTIONS.substring(0, 200) + "...");
}

// Session-aware shared memory that can work with server session management
const createSessionAwareMemory = (sessionId: string) => {
  return {
    _data: new Map(),
    sessionId: sessionId,
    set: function(key: string, value: any) {
      this._data.set(key, value);
      console.log(`üîç [DEBUG] Session ${this.sessionId} Memory set: ${key} = ${value}`);
    },
    get: function(key: string) {
      const value = this._data.get(key);
      console.log(`üîç [DEBUG] Session ${this.sessionId} Memory get: ${key} = ${value}`);
      return value;
    },
    clear: function() {
      this._data.clear();
      console.log(`üîç [DEBUG] Session ${this.sessionId} Memory cleared`);
    },
    // Add required Mastra methods
    __registerMastra: function() {
      console.log(`üîç [DEBUG] Session ${this.sessionId} Memory __registerMastra called`);
      return this;
    },
    getMemory: function() {
      return this;
    },
    hasOwnMemory: function() {
      return true;
    },
    getMemoryTools: function() {
      return [];
    },
    fetchMemory: function() {
      return Promise.resolve([]);
    },
    getMemoryMessages: function() {
      return [];
    },
    setStorage: function(storage: any) {
      console.log(`üîç [DEBUG] Session ${this.sessionId} Memory setStorage called with:`, storage);
      return this;
    }
  };
};

// Default shared memory for backward compatibility
// Create a session-aware memory factory
const createSessionAwareMemoryFactory = () => {
  const memoryInstances = new Map();
  
  return {
    getMemory: (sessionId: string = "default") => {
      if (!memoryInstances.has(sessionId)) {
        memoryInstances.set(sessionId, createSessionAwareMemory(sessionId));
      }
      return memoryInstances.get(sessionId);
    },
    set: (key: string, value: any, sessionId: string = "default") => {
      const memory = memoryInstances.get(sessionId) || createSessionAwareMemory(sessionId);
      memory.set(key, value);
      memoryInstances.set(sessionId, memory);
    },
    get: (key: string, sessionId: string = "default") => {
      const memory = memoryInstances.get(sessionId);
      return memory ? memory.get(key) : undefined;
    }
  };
};

const sharedMemory = createSessionAwareMemoryFactory();

// Working memory template for customer profiles
const WORKING_MEMORY_TEMPLATE = `# Customer Profile
- **Customer ID**: {{customerId}}
- **Store Name**: {{storeName}}
- **Email**: {{email}}
- **Phone**: {{phone}}
- **Location**: {{location}}
- **Last Interaction**: {{lastInteraction}}
- **Current Agent**: {{currentAgent}}
- **Session Start**: {{sessionStart}}`;

// Create a custom delegateTo tool that automatically includes customer ID from memory
const enhancedDelegateTo = {
  ...orchestratorTools.delegateTo,
  execute: async (args: any) => {
    const parsed = args.input || args.context || {};
    const agentId = parsed.agentId || "customer-identification";
    const agentContext = parsed.context || {};
    const message = parsed.message || "È°ßÂÆ¢ÊÉÖÂ†±„ÅÆÁ¢∫Ë™ç„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ";
    
    // Get customer ID from memory if available
    let customerId = agentContext.customerId;
    if (!customerId) {
      try {
        // Try to get customer ID from shared memory
        customerId = sharedMemory.get("customerId");
        if (customerId) {
          console.log(`üîç [DEBUG] Found customer ID from shared memory: ${customerId}`);
        }
      } catch (error) {
        console.log(`‚ùå [DEBUG] Error getting customer ID from memory:`, error);
      }
    }
    
    // If we have a customer ID, add it to the context
    const enhancedContext = customerId ? { ...agentContext, customerId } : agentContext;
    
    console.log(`üîç [DEBUG] Delegating to ${agentId} with context:`, JSON.stringify(enhancedContext));
    
    // Call the original delegateTo tool with enhanced context
    return orchestratorTools.delegateTo.execute({
      ...args,
      context: {
        ...parsed,
        context: enhancedContext
      }
    });
  }
};

// Create a direct repair history tool that bypasses delegation
const directRepairHistoryTool = {
  id: "directRepairHistory",
  description: "Get repair history directly without delegation",
  inputSchema: z.object({
    customerId: z.string().optional().describe("Customer ID to get repair history for"),
    sessionId: z.string().optional().describe("Session ID for memory access"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    data: z.any(),
    message: z.string(),
  }),
  execute: async (args: any) => {
    let { customerId } = args.input || args.context || {};
    console.log(`üîç [DEBUG] REPAIR - Initial customerId from args: ${customerId}`);
    
    // Get sessionId from agent memory
    let sessionId = "default";
    try {
      // Access the agent's memory to get sessionId
      const agentMemory = args.agent?.memory;
      if (agentMemory && typeof agentMemory.get === 'function') {
        sessionId = agentMemory.get("sessionId") || "default";
        console.log(`üîç [DEBUG] REPAIR - Retrieved sessionId from agent memory: ${sessionId}`);
      }
    } catch (error) {
      console.log(`‚ùå [DEBUG] REPAIR - Error getting sessionId from agent memory:`, error);
    }
    
    // If customerId is not provided, try to get it from shared memory using sessionId
    if (!customerId) {
      try {
        customerId = sharedMemory.get("customerId", sessionId);
        console.log(`üîç [DEBUG] REPAIR - Retrieved customer ID from memory (session: ${sessionId}): ${customerId}`);
      } catch (error) {
        console.log(`‚ùå [DEBUG] REPAIR - Error getting customer ID from memory:`, error);
      }
    } else {
      console.log(`üîç [DEBUG] REPAIR - Using provided customerId: ${customerId}`);
    }
    
    if (!customerId) {
      return {
        success: false,
        data: null,
        message: "È°ßÂÆ¢ID„ÅåÂøÖË¶Å„Åß„Åô„ÄÇÂÖà„Å´È°ßÂÆ¢Ë≠òÂà•„ÇíÂÆå‰∫Ü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      };
    }
    
    try {
      console.log(`üîç [DEBUG] Direct repair history lookup for customer ID: ${customerId}`);
      
      // Import the repair tool directly
      const { hybridGetRepairsByCustomerIdTool } = await import("../../tools/sanden/repair-tools");
      
      const result = await hybridGetRepairsByCustomerIdTool.execute({
        context: { customerId }
      });
      
      console.log(`üîç [DEBUG] Direct repair history result:`, JSON.stringify(result, null, 2));
      
      return result;
    } catch (error: any) {
      console.error(`‚ùå [DEBUG] Error in direct repair history:`, error);
      return {
        success: false,
        data: null,
        message: `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`,
      };
    }
  },
};

// Create a direct product lookup tool that bypasses delegation
const directProductLookupTool = {
  id: "directProductLookup",
  description: "Get customer products directly without delegation",
  inputSchema: z.object({
    customerId: z.string().optional().describe("Customer ID to get products for"),
    sessionId: z.string().optional().describe("Session ID for memory access"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    data: z.any(),
    message: z.string(),
  }),
  execute: async (args: any) => {
    let { customerId } = args.input || args.context || {};
    console.log(`üîç [DEBUG] PRODUCT - Initial customerId from args: ${customerId}`);
    
    // Get sessionId from agent memory
    let sessionId = "default";
    try {
      // Access the agent's memory to get sessionId
      const agentMemory = args.agent?.memory;
      if (agentMemory && typeof agentMemory.get === 'function') {
        sessionId = agentMemory.get("sessionId") || "default";
        console.log(`üîç [DEBUG] PRODUCT - Retrieved sessionId from agent memory: ${sessionId}`);
      }
    } catch (error) {
      console.log(`‚ùå [DEBUG] PRODUCT - Error getting sessionId from agent memory:`, error);
    }
    
    // If customerId is not provided, try to get it from shared memory using sessionId
    if (!customerId) {
      try {
        customerId = sharedMemory.get("customerId", sessionId);
        console.log(`üîç [DEBUG] PRODUCT - Retrieved customer ID from memory (session: ${sessionId}): ${customerId}`);
      } catch (error) {
        console.log(`‚ùå [DEBUG] PRODUCT - Error getting customer ID from memory:`, error);
      }
    } else {
      console.log(`üîç [DEBUG] PRODUCT - Using provided customerId: ${customerId}`);
    }
    
    if (!customerId) {
      return {
        success: false,
        data: null,
        message: "È°ßÂÆ¢ID„ÅåÂøÖË¶Å„Åß„Åô„ÄÇÂÖà„Å´È°ßÂÆ¢Ë≠òÂà•„ÇíÂÆå‰∫Ü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      };
    }
    
    try {
      console.log(`üîç [DEBUG] Direct product lookup for customer ID: ${customerId}`);
      
      // Import the product tool directly
      const { hybridGetProductsByCustomerIdTool } = await import("../../tools/sanden/product-tools");
      
      const result = await hybridGetProductsByCustomerIdTool.execute({
        context: { customerId }
      });
      
      console.log(`üîç [DEBUG] Direct product lookup result:`, JSON.stringify(result, null, 2));
      
      return result;
    } catch (error: any) {
      console.error(`‚ùå [DEBUG] Error in direct product lookup:`, error);
      return {
        success: false,
        data: null,
        message: `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`,
      };
    }
  }
};

const directSchedulingTool = {
  id: "directScheduling",
  description: "Handle repair scheduling requests directly without delegation",
  inputSchema: z.object({
    customerId: z.string().optional().describe("Customer ID for scheduling"),
    sessionId: z.string().optional().describe("Session ID for memory access"),
    issueDescription: z.string().optional().describe("Description of the repair issue"),
    scheduledDateTime: z.string().optional().describe("Preferred date and time for repair"),
    priority: z.string().optional().describe("Priority level (Low, Medium, High, Emergency)"),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    data: z.any(),
    message: z.string(),
  }),
  execute: async (args: any) => {
    let { customerId, issueDescription, scheduledDateTime, priority } = args.input || args.context || {};
    console.log(`üîç [DEBUG] SCHEDULING - Initial args:`, { customerId, issueDescription, scheduledDateTime, priority });
    
    // Get sessionId from agent memory
    let sessionId = "default";
    try {
      // Access the agent's memory to get sessionId
      const agentMemory = args.agent?.memory;
      if (agentMemory && typeof agentMemory.get === 'function') {
        sessionId = agentMemory.get("sessionId") || "default";
        console.log(`üîç [DEBUG] SCHEDULING - Retrieved sessionId from agent memory: ${sessionId}`);
      }
    } catch (error) {
      console.log(`‚ùå [DEBUG] SCHEDULING - Error getting sessionId from agent memory:`, error);
    }
    
    // If customerId is not provided, try to get it from shared memory using sessionId
    if (!customerId) {
      try {
        customerId = sharedMemory.get("customerId", sessionId);
        console.log(`üîç [DEBUG] SCHEDULING - Retrieved customer ID from memory (session: ${sessionId}): ${customerId}`);
      } catch (error) {
        console.log(`‚ùå [DEBUG] SCHEDULING - Error getting customer ID from memory:`, error);
      }
    }
    
    if (!customerId) {
      return {
        success: false,
        data: null,
        message: "È°ßÂÆ¢ID„ÅåÂøÖË¶Å„Åß„Åô„ÄÇÂÖà„Å´È°ßÂÆ¢Ë≠òÂà•„ÇíÂÆå‰∫Ü„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
      };
    }
    
    try {
      console.log(`üîç [DEBUG] Direct scheduling for customer ID: ${customerId}`);
      
      // Import the scheduling tool directly
      const { createSchedulingEntry } = await import("../../tools/sanden/scheduling-tools");
      
      // Create scheduling data
      const schedulingData = {
        customerId: customerId,
        companyName: sharedMemory.get("storeName", sessionId || "default") || "",
        email: sharedMemory.get("email", sessionId || "default") || "",
        phone: sharedMemory.get("phone", sessionId || "default") || "",
        location: sharedMemory.get("location", sessionId || "default") || "",
        issueDescription: issueDescription || "‰øÆÁêÜ‰∫àÁ¥Ñ„ÅÆÁî≥„ÅóËæº„Åø",
        scheduledDateTime: scheduledDateTime || new Date().toISOString(),
        priority: priority || "‰∏≠",
        status: "Êú™ÂØæÂøú",
        visitRequired: "Ë¶Å",
        technician: "AI",
        repairId: `REP${Date.now()}`,
      };
      
      console.log(`üîç [DEBUG] Scheduling data:`, JSON.stringify(schedulingData, null, 2));
      
      const result = await createSchedulingEntry.execute({
        context: schedulingData
      });
      
      console.log(`üîç [DEBUG] Direct scheduling result:`, JSON.stringify(result, null, 2));
      
      return result;
    } catch (error: any) {
      console.error(`‚ùå [DEBUG] Error in direct scheduling:`, error);
      return {
        success: false,
        data: null,
        message: `„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`,
      };
    }
  }
};

// Create a custom lookupCustomerFromDatabase tool that stores customer ID in shared memory
const enhancedLookupCustomerFromDatabase = {
  ...orchestratorTools.lookupCustomerFromDatabase,
  inputSchema: z.object({
    ...orchestratorTools.lookupCustomerFromDatabase.inputSchema.shape,
    sessionId: z.string().optional().describe("Session ID for memory access"),
  }),
  execute: async (args: any) => {
    const result = await orchestratorTools.lookupCustomerFromDatabase.execute(args);
    
    // Get sessionId from agent memory
    let sessionId = "default";
    try {
      // Access the agent's memory to get sessionId
      const agentMemory = args.agent?.memory;
      if (agentMemory && typeof agentMemory.get === 'function') {
        sessionId = agentMemory.get("sessionId") || "default";
        console.log(`üîç [DEBUG] LOOKUP - Retrieved sessionId from agent memory: ${sessionId}`);
      }
    } catch (error) {
      console.log(`‚ùå [DEBUG] LOOKUP - Error getting sessionId from agent memory:`, error);
    }
    
    // If customer was found, store the customer ID and profile in shared memory using sessionId
    if (result.found && result.customerData && result.customerData.customerId) {
      try {
        const customerData = result.customerData;
        
        // Store individual fields in memory using sessionId
        sharedMemory.set("customerId", customerData.customerId, sessionId);
        sharedMemory.set("storeName", customerData.storeName, sessionId);
        sharedMemory.set("email", customerData.email, sessionId);
        sharedMemory.set("phone", customerData.phone, sessionId);
        sharedMemory.set("location", customerData.location, sessionId);
        sharedMemory.set("lastInteraction", new Date().toISOString(), sessionId);
        sharedMemory.set("currentAgent", "customer-identification", sessionId);
        sharedMemory.set("sessionStart", new Date().toISOString(), sessionId);
        
        console.log(`üîç [DEBUG] Stored complete customer profile in shared memory (session: ${sessionId}):`, {
          customerId: customerData.customerId,
          storeName: customerData.storeName,
          email: customerData.email,
          phone: customerData.phone,
          location: customerData.location
        });
      } catch (error) {
        console.log(`‚ùå [DEBUG] Failed to store customer profile in shared memory:`, error);
      }
    }
    
    return result;
  }
};

export const routingAgentCustomerIdentification = new Agent({ 
  name: "customer-identification",
  description: "„Çµ„É≥„Éá„É≥„Éª„É™„ÉÜ„Éº„É´„Ç∑„Çπ„ÉÜ„É†‰øÆÁêÜÂèó‰ªòAI , È°ßÂÆ¢Ë≠òÂà•„Ç®„Éº„Ç∏„Çß„É≥„Éà",
  instructions: CUSTOMER_IDENTIFICATION_INSTRUCTIONS,
  model: bedrock("anthropic.claude-3-5-sonnet-20240620-v1:0"),
  tools: {
    ...customerTools,
    ...commonTools,
    delegateTo: enhancedDelegateTo,
    lookupCustomerFromDatabase: enhancedLookupCustomerFromDatabase,
    directRepairHistory: directRepairHistoryTool,
    directProductLookup: directProductLookupTool,
    directScheduling: directSchedulingTool,
  },
  memory: sharedMemory, // Use shared memory
});

console.log("‚úÖ Customer Identification Agent created with instructions length:", CUSTOMER_IDENTIFICATION_INSTRUCTIONS.length);

// Export the shared memory instance for use in other agents
export { sharedMemory };
